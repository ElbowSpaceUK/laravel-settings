{"0": {
    "doc": "Basic Usage",
    "title": "Basic Usage",
    "content": ". ",
    "url": "http://localhost:4000/basic-usage",
    "relUrl": "/basic-usage"
  },"1": {
    "doc": "Creating Settings",
    "title": "Creating a Setting",
    "content": ". | Create a new setting . | Example | Form Field | Validation | Groups | Tags | Encryption | Complex data types | . | Registering | Advanced . | Setting Types | . | . ",
    "url": "http://localhost:4000/create-settings#creating-a-setting",
    "relUrl": "/create-settings#creating-a-setting"
  },"2": {
    "doc": "Creating Settings",
    "title": "Create a new setting",
    "content": "A setting is a class with the following methods, . | The form field for the setting (using the form schema generator) | An array or string of Laravel rules to validate the setting against | A default value | A group. | . Example . &lt;?php use Settings\\Schema\\Setting; class SiteName extends Setting { /** * The default value of the setting. * * @return mixed */ public function defaultValue() { return 'My Site'; } /** * The field schema to show the user when editing the value. * * @throws \\Exception * @return Field */ public function fieldOptions(): \\FormSchema\\Schema\\Field { return \\FormSchema\\Generator\\Field::textInput($this-&gt;inputName())-&gt;setValue($this-&gt;defaultValue()); } /** * Return the validation rules for the setting. * * The key to use for the rules is data. You may also override the validator method to customise the validator further * * @return array */ public function rules(): array|string { return 'string|min:2|max:20'; } /** * @return string */ public static function group(): string { return 'branding'; } } . These classes should extend a setting type such as Settings\\Schema\\UserSetting or Settings\\Schema\\GlobalSetting. Form Field . Form fields are defined using the form schema generator. You can define any field you need here, including complex fields that return objects. The input name for the field is defined in $this-&gt;inputName(), and the default value in $this-&gt;defaultValue() so to define a simple text field you’d use this plus a label/hint/other fields. public function fieldOptions(): \\FormSchema\\Schema\\Field { return \\FormSchema\\Generator\\Field::textInput($this-&gt;inputName())-&gt;setValue($this-&gt;defaultValue()); } . Validation . To ensure the settings entered into the database are valid, you can define rules in the rules array. This can be an array or string of rules, that will validate a valid value. There’s no need to put required/optional rules in, but do include nullable if the option can be null. public function rules(): array|string { return 'string|min:2|max:20'; } . Groups . Groups are a way to order settings to the user. By grouping together similar settings (such as those related to the site theme, authentication, emails etc), it helps users quickly find what they’re looking for. To define a group, define a group function. public function group(): string { return 'branding'; } . See the integrate section for information about how to add metadata to these. Tags . Tags can be used to further sort settings. These are simple strings that can later be used to retrieve matching settings. To define settings, define a tags function. public function tags(): array { return ['appearance', 'text', 'language']; } . Encryption . If the data in the setting is sensitive, it can be encrypted automatically using the Laravel encryption tools. To turn on encryption for a setting, make sure to implement the \\Settings\\Contracts\\ShouldEncrypt interface on the setting. Complex data types . All values in the database are automatically serialised to preserve type. This means that arrays and objects will all be saved and retrieved in the correct format, so you don’t have to worry about how your setting is saved. If you want to control how the setting is saved in the database, define castToString and castToValue functions on the setting which will convert your validated setting value to a database-friendly string and back. This example would handle an array (though would be pointless since arrays are already casted automatically). public function castToString(array $value): string { return json_encode($value); } public function castToValue(string $value): array { return json_decode($value, true); } . ",
    "url": "http://localhost:4000/create-settings#create-a-new-setting",
    "relUrl": "/create-settings#create-a-new-setting"
  },"3": {
    "doc": "Creating Settings",
    "title": "Registering",
    "content": "You can then register settings in the boot function of a service provider using the facade, or replace \\Settings\\Setting:: with settings()-&gt; to use the helper function. You can also register information about groups, which will be automatically pulled into any form schemas you extract from settings. public function boot() { \\Settings\\Setting::register(\\Acme\\Setting\\SiteName::class); \\Settings\\Setting::register([ \\Acme\\Setting\\SiteName::class, \\Acme\\Setting\\SiteTheme::class ]); \\Settings\\Setting::register(\\Acme\\Setting\\SiteName::class, ['extra', 'tags', 'for', 'the', 'setting']); \\Settings\\Setting::registerGroup( 'branding', // Group Key 'Branding', // Title for the group 'Settings related to the site brand' // Description for the group ); } . You can also register settings and groups in the config . &lt;?php // config/settings.php return [ 'settings' =&gt; [ \\Acme\\Setting\\SiteName::class, \\Acme\\Setting\\SiteTheme::class, ... ], 'groups' =&gt; [ 'branding' [ 'title' =&gt; 'Branding', 'subtitle' =&gt; 'Settings related to the site brand' ], ] ]; . ",
    "url": "http://localhost:4000/create-settings#registering",
    "relUrl": "/create-settings#registering"
  },"4": {
    "doc": "Creating Settings",
    "title": "Advanced",
    "content": "Setting Types . By default, you have the setting types global and user. The global setting type is set once, and will be the same for everyone. But a user setting will return a different value depending on which user is logged in. For some sites, the settings will depend on the team a user is in, the module you’re operating in, or the country you’re in. When creating a setting, you can assign it to be of one type. Whenever you then get the value of that setting, it will depend on the model logged in. To create a new type, create an abstract class that implements Settings\\Contracts\\SettingType. abstract class TeamSettingType implements \\Settings\\Contracts\\SettingType { /** * Get the ID of the currently logged in model (in this case, the team id) * * Returning null will just return the setting value as the default value. * * @return int|null */ public function resolveId(): ?int { if(\\App\\Team\\Resolver::hasCurrentTeam()) { return \\App\\Team\\Resolver::currentTeam()-&gt;id(); } return null; } } . ",
    "url": "http://localhost:4000/create-settings#advanced",
    "relUrl": "/create-settings#advanced"
  },"5": {
    "doc": "Creating Settings",
    "title": "Creating Settings",
    "content": " ",
    "url": "http://localhost:4000/create-settings",
    "relUrl": "/create-settings"
  },"6": {
    "doc": "Get Settings",
    "title": "Get Settings",
    "content": ". | Getting a setting value . | Getting values for types | . | Getting setting information | . ",
    "url": "http://localhost:4000/get-settings",
    "relUrl": "/get-settings"
  },"7": {
    "doc": "Get Settings",
    "title": "Getting a setting value",
    "content": "The easiest way to get the value of a setting is by referencing the setting class directly, e.g. \\Acme\\Setting\\SiteName::getValue(). You can also use . | The facade: \\Settings\\Setting::getValue(\\Acme\\Setting\\SiteName::class) | The helper: settings(\\Settings\\Setting::class) | . Getting values for types . For setting types like users and teams, where the setting value depends on the session, you can use the same function. This will automatically resolve the current user/team/model from the session and use that. If you do pass an ID in as the first parameter though, it will get the setting value for the given model instead. ",
    "url": "http://localhost:4000/get-settings#getting-a-setting-value",
    "relUrl": "/get-settings#getting-a-setting-value"
  },"8": {
    "doc": "Get Settings",
    "title": "Getting setting information",
    "content": "To display the settings to users, you need to get information about the registered settings. These all use the setting service class, which you can access through the facade or the helper (passing it no parameters). Group . | Get all settings from a group: settings()-&gt;withGroup('group-name')-&gt;get() | . Tags . | Get all settings with a given tag: \\Settings\\Setting::withTag('tag-name')-&gt;get() | Get all settings with any of the given tags: settings()-&gt;withAnyTags(['tag-name', 'tag-name-2'])-&gt;get() | Get all settings with all the given tags: settings()-&gt;withAllTags(['tag-name', 'tag-name-2'])-&gt;get() | . Types . | Get all settings of a certain type: settings()-&gt;withType(\\Acme\\Setting\\TeamSettingType::class)-&gt;get() | Get all global settings: settings()-&gt;withGlobal()-&gt;get(). This is the same as calling settings()-&gt;withType(\\Settings\\Schema\\GlobalSetting::class). | Get all user settings: settings()-&gt;withUser()-&gt;get(). | . The functions can be chained, so to get all global settings that belong to a group called ‘Blog Module’, you’d use \\Settings\\Setting::withGlobal()-&gt;withGroup('blog-module')-&gt;get(). These will all return a Settings\\Support\\SettingCollection instance. You can use this like a normal Laravel collection, but you will also have access to the following functions. | asForm() - turn the settings into a \\FormSchema\\Schema\\Form. | toKeyValuePair() - get all settings and their values as key value pairs. | . ",
    "url": "http://localhost:4000/get-settings#getting-setting-information",
    "relUrl": "/get-settings#getting-setting-information"
  },"9": {
    "doc": "Introduction",
    "title": "Laravel Settings",
    "content": "Contents . | Introduction | Installation | . ",
    "url": "http://localhost:4000/index#laravel-settings",
    "relUrl": "/index#laravel-settings"
  },"10": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": " ",
    "url": "http://localhost:4000/index",
    "relUrl": "/index"
  },"11": {
    "doc": "Introduction",
    "title": "Installation",
    "content": "All you need to do to use this project is pull it into an existing Laravel app using composer. composer require twigger/laravel-settings . You can publish the configuration file by running . php artisan vendor:publish --provider=\"Settings\\SettingsServiceProvider\" . ",
    "url": "http://localhost:4000/index#installation",
    "relUrl": "/index#installation"
  },"12": {
    "doc": "Integrate",
    "title": "Basic Usage",
    "content": ". | API . | Get a setting value . | Request | Response | . | Set a setting value(s) . | Request | Response | . | Get all setting values . | Request | Response | . | . | Validation | Creating a settings page | . ",
    "url": "http://localhost:4000/integrating#basic-usage",
    "relUrl": "/integrating#basic-usage"
  },"13": {
    "doc": "Integrate",
    "title": "API",
    "content": "This package comes with an API for updating the settings. Get a setting value . Request . GET /_setting/{key} HTTP/1.1 Accept: application/json Content-Type: application/json . Response . HTTP/1.1 200 OK Content-Type: application/json { \"setting\": { key: '', value: '', updated_at: '' } } . Set a setting value(s) . POST /setting [ {“value”: “setting-value”} ] . Request . POST /_setting HTTP/1.1 Accept: application/json Content-Type: application/json { \"settings\": { \"key1\": \"First setting\", \"key2\": \"Second setting\" ] } . Response . HTTP/1.1 204 No Content Content-Type: application/json . Get all setting values . Request . GET /_setting HTTP/1.1 Accept: application/json Content-Type: application/json . Response . HTTP/1.1 200 OK Content-Type: application/json { \"settings\": [ { key: '', value: '', updated_at: '' }, {...}, ] } . ",
    "url": "http://localhost:4000/integrating#api",
    "relUrl": "/integrating#api"
  },"14": {
    "doc": "Integrate",
    "title": "Validation",
    "content": "If you use your own API to update settings, or a standard web request, you can use the following validation rule to check all the given settings are valid according to their validation rules . | settings - the given attribute must be an array of settings as key value pairs | . ",
    "url": "http://localhost:4000/integrating#validation",
    "relUrl": "/integrating#validation"
  },"15": {
    "doc": "Integrate",
    "title": "Creating a settings page",
    "content": "We’ve previously covered getting a Form instance from settings/groups of settings. Pass this schema to the frontend and render it using a dynamic form generator. Each setting group will appear in a different form group. ",
    "url": "http://localhost:4000/integrating#creating-a-settings-page",
    "relUrl": "/integrating#creating-a-settings-page"
  },"16": {
    "doc": "Integrate",
    "title": "Integrate",
    "content": " ",
    "url": "http://localhost:4000/integrating",
    "relUrl": "/integrating"
  },"17": {
    "doc": "JS",
    "title": "JavaScript",
    "content": ". | Vue | Setting Keys | JS | . ",
    "url": "http://localhost:4000/js#javascript",
    "relUrl": "/js#javascript"
  },"18": {
    "doc": "JS",
    "title": "Vue",
    "content": "Since the frontend makes use of the settings too, it’s easy to use this package directly from your js. You will need to install the js package. If using Vue, add the following to your app.js file. Here we use 1 as the model ID, replace with whatever the actual model ID is. import Settings from '@twigger/settings'; Vue.use(Settings); . Then in your Vue app . &lt;template&gt; Setting value: { { $setting.get('key', 1) } } &lt;/template&gt; &lt;!--...--&gt; computed: { description() { return this.$setting.get('key', 1) } } . ",
    "url": "http://localhost:4000/js#vue",
    "relUrl": "/js#vue"
  },"19": {
    "doc": "JS",
    "title": "Setting Keys",
    "content": "On the PHP side, since all settings are class based it’s impossible to use the incorrect setting key. To keep this consistency in js, the keys can be retrieved from a json object. This is automatically generated for you. For our site name example (\\Acme\\Settings\\SiteName), this looks like . { acme: { settings: { siteName: SettingObject } } } . You can access this object with this.$setting.keys. Once you have a setting object, you can call the following functions . | this.$setting.keys.acme.settings.siteName.get(1) - Get the value for the model with an ID 1 | ...siteName.get() - Get the default value/global setting value | ...siteName.set('value', 1) - Set the value for the model 1 | ...siteName.set('value') - Set the default/global value | . ",
    "url": "http://localhost:4000/js#setting-keys",
    "relUrl": "/js#setting-keys"
  },"20": {
    "doc": "JS",
    "title": "JS",
    "content": "Using functions directly . import {getSetting, keys} from '@twigger/settings' getSetting('key', 1) // keys is an object of keys as above . ",
    "url": "http://localhost:4000/js",
    "relUrl": "/js"
  },"21": {
    "doc": "Set Settings",
    "title": "Set Settings",
    "content": ". | Set a setting value . | Setting types | . | . ",
    "url": "http://localhost:4000/set-settings",
    "relUrl": "/set-settings"
  },"22": {
    "doc": "Set Settings",
    "title": "Set a setting value",
    "content": "To set a setting, you can use the setValue method on the setting, such as Acme\\Setting\\SiteName::setValue('New site name'). This will set the setting value, or throw a validation exception if there was a problem with the value. Setting types . Most setting types (such as user and team settings) have a value that depends on the current session. For these settings, you may pass in the ID of the user/team/model as a second parameter. \\Acme\\Setting\\Team2FAEnabled::setValue(true, 5) will enable 2FA for the team with an ID of 5. For the settings that depend on a model like this, if you don’t pass an ID in as the second parameter it will be automatically resolved from the session. To update the default, which will affect any users that haven’t changed their settings yet, you can use \\Acme\\Setting\\Team2FAEnabled::setDefaultValue(true) to enable 2FA by default. ",
    "url": "http://localhost:4000/set-settings#set-a-setting-value",
    "relUrl": "/set-settings#set-a-setting-value"
  }
}
