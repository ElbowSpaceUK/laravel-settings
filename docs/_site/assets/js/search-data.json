{"0": {
    "doc": "Advanced",
    "title": "Laravel Settings",
    "content": "Contents . | Laravel Settings . | Using settings in service providers | Setting Types | . | . ",
    "url": "/advanced/advanced#laravel-settings",
    "relUrl": "/advanced/advanced#laravel-settings"
  },"1": {
    "doc": "Advanced",
    "title": "Using settings in service providers",
    "content": "It can be tempting to use a setting in your service provider, to store things like service credentials that are needed to set it up. However, the settings package isn’t ready to use until the application is fully booted, since it depends on things like cache, encryption and its own bindings to function. If you try to use it before the application is booted, you’ll get an exception. To work around this, so you can use settings to set up services needed by the rest of your app, you can use the booted callback on the application. In the register function of your service provider, define a callback which should be called after the application is booted. This will be called as soon as the application is booted, meaning you can do any service setup here and make use of the settings. The easier option is to register your bindings as a callback, which should only be called once the service is actually requested. But either option is equally fine and you can use whichever suits the situation best! . ",
    "url": "/advanced/advanced#using-settings-in-service-providers",
    "relUrl": "/advanced/advanced#using-settings-in-service-providers"
  },"2": {
    "doc": "Advanced",
    "title": "Setting Types",
    "content": "Learn how to create a custom setting type in the setting type documentation. ",
    "url": "/advanced/advanced#setting-types",
    "relUrl": "/advanced/advanced#setting-types"
  },"3": {
    "doc": "Advanced",
    "title": "Advanced",
    "content": " ",
    "url": "/advanced/advanced",
    "relUrl": "/advanced/advanced"
  },"4": {
    "doc": "Setting Types",
    "title": "Setting Types",
    "content": "Contents . | What are setting types | Configure user settings | Creating a custom type | . ",
    "url": "/advanced/setting-types",
    "relUrl": "/advanced/setting-types"
  },"5": {
    "doc": "Setting Types",
    "title": "What are setting types",
    "content": "By default, we provide a user setting type and a global setting type. The global setting type is set once within your application, and will be the same for all authenticated users. But a user setting will return a different value depending on which user is logged in, meaning a user can control the setting themselves. For some sites, the settings will depend on the team a user is in, the module you’re operating in, or the country you’re in. When creating a setting, you can assign it to be of one type. Whenever you then get the value of that setting, it will depend on the model logged in. ",
    "url": "/advanced/setting-types#what-are-setting-types",
    "relUrl": "/advanced/setting-types#what-are-setting-types"
  },"6": {
    "doc": "Setting Types",
    "title": "Configure user settings",
    "content": "By default, the user settings uses the Laravel Auth facade to resolve the user ID. If your app gets users a different way, you can override this functionality with a callback in the register function of your service provider. `\\Settings\\Types\\UserSetting::$resolveUserUsing = fn() =&gt; \\Auth::driver('api')-&gt;id();` . ",
    "url": "/advanced/setting-types#configure-user-settings",
    "relUrl": "/advanced/setting-types#configure-user-settings"
  },"7": {
    "doc": "Setting Types",
    "title": "Creating a custom type",
    "content": "To create a new type, create an abstract class that implements Settings\\Contracts\\SettingType. This should implement at least the resolveId function. This function takes no arguments, and should return the ID of the currently logged in user/team etc, or null if not logged in. abstract class TeamSettingType implements \\Settings\\Contracts\\SettingType { /** * Get the ID of the currently logged in model (in this case, the team id) * * Returning null will just return the setting value as the default value. * * @return int|null */ public function resolveId(): ?int { if(\\App\\Team\\Resolver::hasCurrentTeam()) { return \\App\\Team\\Resolver::currentTeam()-&gt;id(); } return null; } } . To use your custom type, simply create a new setting class that extends your type. This replaces the user or global setting class you usually extend. If you use anonymous settings you can’t extend this class. Instead, you should create the type in your service provider as follows. public function boot() { \\Settings\\Anonymous\\AnonymousSettingFactory::mapType( // The key to refer to the type as 'team', // Return the current team ID, or null if there is no team. This will be used to filter the settings. fn() =&gt; \\App\\Team\\Resolver::hasCurrentTeam() ? \\App\\Team\\Resolver::currentTeam()-&gt;id() : null ); } . This can then be used when registering the anonymous setting. Instead of \\Setting\\Setting::createGlobal or createUser, simply call \\Setting\\Setting::create(team: 'team', ...); and pass through the type key as the first argument. If the setting type is only going to be used in one setting and you don’t want to create a type, you can just implement the resolveId function directly in your setting, or pass it into the create function as the resolveIdUsing function. The type can be anything you want and won’t be used. public function boot() { \\Settings\\Setting::create( 'team', // Although you still have to define a type, it doesn't mean any thing and doesn't have to exist. This can be useful for retrieving settings though. 'siteName', // The key 'My App', // The default value \\FormSchema\\Generator\\Field::textInput($this-&gt;key())-&gt;setValue($this-&gt;defaultValue()), // The form field ['branding', 'appearance'], // The groups the setting is in ['string'], // The laravel validation rules, fn() =&gt; \\App\\Team\\Resolver::hasCurrentTeam() ? \\App\\Team\\Resolver::currentTeam()-&gt;id() : null ) } . ",
    "url": "/advanced/setting-types#creating-a-custom-type",
    "relUrl": "/advanced/setting-types#creating-a-custom-type"
  },"8": {
    "doc": "Basic Usage",
    "title": "Laravel Settings",
    "content": "Contents . | Laravel Settings . | Basic Usage . | Getting Values | Setting Values | User/Global Settings | Registering settings | . | . | . ",
    "url": "/basic-usage#laravel-settings",
    "relUrl": "/basic-usage#laravel-settings"
  },"9": {
    "doc": "Basic Usage",
    "title": "Basic Usage",
    "content": "Getting Values . You can either get a setting value using the facade or the helper function . | \\Settings\\Setting::getValue('siteName'); // My App Name | settings('siteName'); // My App Name | . If this is a setting specific to a user, such as light/dark mode selection, you may pass an ID through as the second parameter. If the ID is not given, it will default to Auth::id(). | settings('darkMode', $user-&gt;id); // true or false | . You can also reference every setting directly using the facade without calling getValue. | \\Settings\\Setting::getSiteName() | . Setting Values . Setting values is just as easy. These can be done through the facade . \\Settings\\Setting::setValue('siteName', 'New site name') . User/Global Settings . This package supports user and global settings out of the box, along with letting you add your own types. By default, user settings will use the logged in user to retrieve settings for. Pass in an optional ID to getValue or setValue to override this behavious. \\Settings\\Setting::setValue('darkMode', true, $user-&gt;id); // Enable dark mode for a different user . To set a default setting dynamically, for example if you want to make dark mode enabled by default, you should call setDefaultValue. This will set the value for any users who have not overridden it themselves, and will take precedence over the hardcoded default value set when registering the setting. \\Setting\\Setting::setDefaultValue('darkMode', true) . Registering settings . All settings must be registered before you can use them. The setting facade gives you a createUser and createGlobal function to create a user or a global function. These take two required arguments, which are the key of the setting and the default value of the setting. \\Setting\\Setting::createGlobal( key: 'siteName', defaultValue: 'My Site Name', fieldOptions: null, groups: ['branding', 'appearance'], rules: ['string', 'max:255'] ); . As above, you may also pass . | An array of groups. These ‘categorise’ the settings, and are useful when dynamically creating settings pages. We will cover this later. | Laravel validation rules. Any time you set a setting value, we will validate the value. | . ",
    "url": "/basic-usage",
    "relUrl": "/basic-usage"
  },"10": {
    "doc": "Class-based Settings",
    "title": "Class-based Settings",
    "content": "Contents . | Class-based Settings . | Introduction | Defining a class setting | Getting/setting values | Registering settings | Settings in depth . | Permissions | Form Field | Validation | Groups | Encryption | Complex data types | . | Migrating to class-based from anonymous | . | . ",
    "url": "/class-based",
    "relUrl": "/class-based"
  },"11": {
    "doc": "Class-based Settings",
    "title": "Introduction",
    "content": "The basic settings covered so far are called anonymous settings, and they are a very flexible way of managing settings. As your app starts to grow, you may find you start forgetting which setings you have created. Class-based settings are just a simple class containing information about the setting. This not only lets you benefit from typehinting during development and limits key clashes, but it also gives you a few extra customisations for your settings. Both methods of creating settings are valid, and often you’ll find yourself using a mixture of the two. They are both fundamentally the same, so there are no large feature differences between them. ",
    "url": "/class-based#introduction",
    "relUrl": "/class-based#introduction"
  },"12": {
    "doc": "Class-based Settings",
    "title": "Defining a class setting",
    "content": "We recommend keeping all your settings in an app/Settings directory. Each setting should be its own class which extends either Settings\\Schema\\UserSetting or Settings\\Schema\\GlobalSetting. Your IDE should tell you which methods you need to implement. &lt;?php use Settings\\Schema\\UserSetting; use Settings\\Schema\\GlobalSetting; class SiteName extends GlobalSetting { /** * The default value of the setting. * * @return mixed */ public function defaultValue() { return 'My Site Name'; } /** * The field schema to show the user when editing the value. * * @throws \\Exception * @return Field */ public function fieldOptions(): \\FormSchema\\Schema\\Field { return \\FormSchema\\Generator\\Field::textInput($this-&gt;key())-&gt;setValue($this-&gt;defaultValue()); } /** * Return the validation rules for the setting. * * The key to use for the rules is data. You may also override the validator method to customise the validator further * * @return array */ public function rules(): array|string { return 'string|min:2|max:20'; } /** * @return array */ public static function group(): array { return ['branding', 'appearance']; } } . ",
    "url": "/class-based#defining-a-class-setting",
    "relUrl": "/class-based#defining-a-class-setting"
  },"13": {
    "doc": "Class-based Settings",
    "title": "Getting/setting values",
    "content": "You can use class-based settings exactly the same as anonymous settings. Instead of a key such as site_name, you can use the class name instead. \\Settings\\Setting::getValue(\\App\\Settings\\SiteName::class) . You can also use the class directly . \\App\\Settings\\SiteName::getValue(). ",
    "url": "/class-based#gettingsetting-values",
    "relUrl": "/class-based#gettingsetting-values"
  },"14": {
    "doc": "Class-based Settings",
    "title": "Registering settings",
    "content": "Once you’ve created a setting you must register it, so your app knows what settings are available. This is usually done in the boot function of a service provider using the facade or helper function. public function boot() { \\Settings\\Setting::register(new \\App\\Setting\\SiteName()); \\Settings\\Setting::register([ // Create a new class instance manually new \\App\\Setting\\SiteName(), // Letting the service container build the setting means you can inject dependencies into the setting construct. $this-&gt;app-&gt;make(\\App\\Setting\\SiteTheme::class) ]); \\Settings\\Setting::register(new \\App\\Setting\\SiteName(), ['extra', 'groups', 'for', 'the', 'setting']); } . ",
    "url": "/class-based#registering-settings",
    "relUrl": "/class-based#registering-settings"
  },"15": {
    "doc": "Class-based Settings",
    "title": "Settings in depth",
    "content": "Permissions . You can control who can update and read specific settings. By default anyone can update or read any settings. If you want to limit this for added protection, you can add a canWrite and canRead function to class-based settings. These take no arguments and should return a boolean. public function canRead(): bool { return Auth::check() &amp;&amp; Auth::user()-&gt;can('read-this-setting'); } public function canWrite(): bool { return Auth::check() &amp;&amp; Auth::user()-&gt;can('write-this-setting'); } . We will take care of ensuring a user has permission before they update a setting. Form Field . Form fields are defined using the form schema generator. This allows you to define the form field to update the setting alongside the rest of the setting definition, then automatically create settings pages for your users. You can define any field you need here, including complex fields. The input name for the field is defined in $this-&gt;key(), and the default value in $this-&gt;defaultValue(). When using anonymous settings, hardcode the key and value and just pass the result of the field generator directly to ::create. // app/Settings/Class.php public function fieldOptions(): \\FormSchema\\Schema\\Field { return \\FormSchema\\Generator\\Field::textInput($this-&gt;key())-&gt;setValue($this-&gt;defaultValue()); } // ServiceProvider.php \\Settings\\Setting::createGlobal(..., fieldOptions: \\FormSchema\\Generator\\Field::textInput('mykey')-&gt;setValue('myvalue')) . Fields are currently a required property of any setting, to allow you to dynamically create setting pages. Validation . To ensure the settings entered into the database are valid, you can define an array or string of Laravel rules in the rules method. If a setting is updated that does not match validation, a validation exception will be thrown and the setting not saved. There’s no need to put required/optional rules in, but do include nullable if the option can be null. public function rules(): array|string { return 'string|min:2|max:20'; } . Groups . Groups are a way to order settings to the user. By grouping together similar settings (such as those related to the site theme, authentication, emails), it helps users quickly find what they’re looking for. The group function should return an array of groups the setting is in. When retrieving a form schema to represent settings, the first group will be taken as the ‘main’ group. public function group(): array { return ['branding', 'appearance']; } . To further pad out your settings page, you can add a name and description to any group in your service provider. \\Settings\\Setting::registerGroup( 'branding', // Group Key 'Branding', // Title for the group 'Settings related to the site brand' // Description for the group ); . Encryption . To protect sensitive settings in the database, values can automatically be encrypted and decrypted for you. You can mark a setting as sensitive by adding a $shouldEncrypt property to the setting class. protected boolean $shouldEncrypt = true; . Encrypting and decrypting add very little overhead, so you may automatically encrypt all settings unless otherwise specified. To do this, set encryption to false in the config file. Anonymous settings use this behaviour to determine whether they should be encrypted. // config/laravel-settings.php return [ ..., 'encryption' =&gt; [ 'default' =&gt; false ] ] . Complex data types . All values in the database are automatically serialised to preserve type. This means that arrays and objects will all be saved and retrieved in the correct format, so you can always retrieve the value of a setting exactly the same as it was when you set it. All primitive types can be serialized already so you don’t need to worry about this. If you want to save a complex object and control how it is saved in the daabase, you can implement the \\Settings\\Contract\\CastsSettingValue interface on your setting. You will need to define a castToString and castToValue functions on the setting which will convert your validated setting value to a database-friendly string and back. This example would handle a complex data object, such as something returned from an API client. /** * Turn the API result into a string that can be saved in the database */ public function castToString(\\My\\Api\\Result $value): string { return json_encode([ 'id' =&gt; $value-&gt;getId(), 'result' =&gt; $value-&gt;getResult() ]); } /** * Turn the string back into an instance of the API result class */ public function castToValue(string $value): \\My\\Api\\Result { $value = json_decode($value, true); return new \\My\\Api\\Result($value['id']) -&gt;setResult($value['result']); } . ",
    "url": "/class-based#settings-in-depth",
    "relUrl": "/class-based#settings-in-depth"
  },"16": {
    "doc": "Class-based Settings",
    "title": "Migrating to class-based from anonymous",
    "content": "Often you will start using anonymous settings and move to class-based settings as your application grows. To make this as simple as possible, you can alias a class-based setting and use it as though it was an anonymous setting. To migrate over to class-based settings, you should create each setting as a class-based setting and add an alias, with a key matching the anonymous setting. Then, delete the anonymous setting creation function call in your service provider. You can alias a setting through config or the service provider, or define it directly on your setting class. You only need to use one of the following methods. // config/settings.php return [ 'aliases' =&gt; [ 'site_name' =&gt; \\App\\Setting\\SiteName::class, ... ] ]; . // app/Providers/AppServiceProvider.php public function boot() { settings()-&gt;alias('site_name', \\App\\Setting\\SiteName::class); \\Settings\\Setting::alias('site_name', \\App\\Setting\\SiteName::class); } . // app/Settings/SiteName.php public function alias(): ?string { return 'site_name'; } . You can now use the site name setting as though it had a key siteName, and so access the setting in the following ways. Same as anonymous . | settings('site_name') | \\Settings\\Setting::getValue('site_name') | \\Settings\\Setting::getSiteName() | settings()-&gt;getValue('site_name') | settings()-&gt;getSiteName() | . Only for class-based . | \\App\\Settings\\SiteName::getValue() | \\Settings\\Setting::getValue(\\App\\Settings\\SiteName::class) | . ",
    "url": "/class-based#migrating-to-class-based-from-anonymous",
    "relUrl": "/class-based#migrating-to-class-based-from-anonymous"
  },"17": {
    "doc": "Introduction",
    "title": "Laravel Settings",
    "content": "Contents . | Laravel Settings . | Introduction | Installation | Basic Usage | . | . ",
    "url": "/index#laravel-settings",
    "relUrl": "/index#laravel-settings"
  },"18": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "Laravel Settings provides simple but flexible settings to any Laravel app. | Quick to set up and use. | Native support for using settings in Vue. | Built to scale alongside your application. | Supports encryption of values and storing non-primitive values. | User and global settings supported by default. | . ",
    "url": "/index",
    "relUrl": "/index"
  },"19": {
    "doc": "Introduction",
    "title": "Installation",
    "content": "All you need to do to use this project is pull it into an existing Laravel app using composer. composer require elbowspaceuk/laravel-settings . You can publish the configuration file by running . php artisan vendor:publish --provider=\"Settings\\SettingsServiceProvider\" . This will publish the configuration file and migrations. ",
    "url": "/index#installation",
    "relUrl": "/index#installation"
  },"20": {
    "doc": "Introduction",
    "title": "Basic Usage",
    "content": "You can create a new setting in the boot method of any service provider. public function boot() { \\Settings\\Setting::createGlobal( key: 'siteName', defaultValue: 'My App' ); } . This setting can then be accessed anywhere in your Laravel application . echo \\Settings\\Setting::getValue('siteName') // My App . or updated to a new value . \\Settings\\Setting::setValue('siteName', 'My New App'); . ",
    "url": "/index#basic-usage",
    "relUrl": "/index#basic-usage"
  },"21": {
    "doc": "Settings UI",
    "title": "Settings UI",
    "content": ". | Settings UI . | Query settings | Create a form instance . | Custom form creator | . | Using the Form | . | . ",
    "url": "/settings-ui",
    "relUrl": "/settings-ui"
  },"22": {
    "doc": "Settings UI",
    "title": "Query settings",
    "content": "To display the settings to users, you need to get information about the registered settings. These all use the setting service class, which you can access through the facade or the helper (passing it no parameters). Groups . | Get all settings with a given group: \\Settings\\Setting::withGroup('group-name')-&gt;get() | Get all settings with at least one of the given groups: settings()-&gt;withAnyGroup(['group-name', 'group-name-2'])-&gt;get() | Get all settings that have all the given groups: settings()-&gt;withAllGroups(['group-name', 'group-name-2'])-&gt;get() | . Types . | Get all settings of a certain type: settings()-&gt;withType(\\Acme\\Setting\\TeamSettingType::class)-&gt;get() or settings()-&gt;withType('team')-&gt;get(). | Get all global settings: settings()-&gt;withGlobal()-&gt;get(). This is the same as calling settings()-&gt;withType(\\Settings\\Schema\\GlobalSetting::class). | Get all user settings: settings()-&gt;withUser()-&gt;get(). | . The functions can be chained, so to get all global settings that belong to a group called ‘Blog Module’, you’d use \\Settings\\Setting::withGlobal()-&gt;withGroup('blog-module')-&gt;get(). ",
    "url": "/settings-ui#query-settings",
    "relUrl": "/settings-ui#query-settings"
  },"23": {
    "doc": "Settings UI",
    "title": "Create a form instance",
    "content": "get() will always return a Settings\\Support\\SettingCollection instance. You can use this like a normal Laravel collection, but you will also have access to the following functions. | toForm() - turn the settings into a \\FormSchema\\Schema\\Form. | toKeyValuePair() - get all settings and their values as key value pairs. | . Custom form creator . When using toForm, you can change how a collection casts settings to a form. Define a callback in the register function of your service provider, which accepts a collection of settings and returns a Form Schema instance. public function register() { \\Settings\\Collection\\SettingCollection::$convertToFormUsing = function(\\Settings\\Collection\\SettingCollection $settings) { return \\FormSchema\\Generator\\Form::make()-&gt;withGroup(&lt;...&gt;)-&gt;form(); } } . ",
    "url": "/settings-ui#create-a-form-instance",
    "relUrl": "/settings-ui#create-a-form-instance"
  },"24": {
    "doc": "Settings UI",
    "title": "Using the Form",
    "content": "This section is incomplete . Pass this schema to the frontend and render it using a dynamic form generator. Each setting group will appear in a different form group. ",
    "url": "/settings-ui#using-the-form",
    "relUrl": "/settings-ui#using-the-form"
  },"25": {
    "doc": "Vue",
    "title": "Vue",
    "content": ". | Setup | Getting values | Setting values | Loading . | Loading through JS | Eager Loading | . | . If you’re using Vue, we’ve put together a package to let you access and change settings directly from your components. ",
    "url": "/vue",
    "relUrl": "/vue"
  },"26": {
    "doc": "Vue",
    "title": "Setup",
    "content": "Install First you’ll need to install the package using npm or yarn. npm install --save @elbowspaceuk/laravel-settings-vue yarn add @elbowspaceuk/laravel-settings-vue . Initialise In your app.js file, where you create your Vue instance, add the following to initialise the plugin. // app.js import Settings from '@elbowspaceuk/laravel-settings-vue'; Vue.use(Settings, { axios: axios }); . Note you must pass an axios instance to the Settings plugin. This must be ready to make api calls - if you are using the standard Laravel template this is set up for you and bound to window.axios, so the above snippet will work. Eager load settings You should also add the \\Settings\\Http\\Middleware\\ShareSettingsWithJs middleware to your web group in app/Http/Kernel.php. protected $middlewareGroups = [ 'web' =&gt; [ ... \\Settings\\Http\\Middleware\\ShareSettingsWithJs::class, ], ]; . Share settings Finally, add @settings to the head of your base blade template. // layout.blade.php &lt;head&gt; &lt;title&gt;...&lt;/title&gt; @settings &lt;/head&gt; . ",
    "url": "/vue#setup",
    "relUrl": "/vue#setup"
  },"27": {
    "doc": "Vue",
    "title": "Getting values",
    "content": "From any Vue component, in the template or a method/computed property/watcher, you have access to a $setting property and a $settings property. The $setting property contains a key-value pair object with all the available settings and their values. This is reactive, so you can use it anywhere in your component. The $settings property contains a set of functions to help you work with settings in js. &lt;template&gt; &lt;div&gt;Your theme is { { $setting.theme } }&lt;/div&gt; &lt;div&gt;Through a computed property it's the same: &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { computed: { currentTheme() { return this.$setting.theme; } } } &lt;/script&gt; . ",
    "url": "/vue#getting-values",
    "relUrl": "/vue#getting-values"
  },"28": {
    "doc": "Vue",
    "title": "Setting values",
    "content": "When you set a setting, we make an API call in the background to update the setting on your server. For this to work, you must not have disabled the API in the configuration, and you should ensure API calls can be made using axios. To set a setting value you should call this.$settings.setValue('site_name', 'My new site name') in your Vue component. You can set multiple at a time by passing through an object of key-value pairs of settings to this.$settings.setValues(). You can also just set $setting directly with this.$setting.site_name = 'My New Site Name'. If you’re working with an input that uses v-model, you can use the setting directly. This will automatically update the value in your database when v-model is triggered. &lt;template&gt; &lt;input type=\"checkbox\" v-model=\"$setting.dark_mode\" /&gt; &lt;/template&gt; . ",
    "url": "/vue#setting-values",
    "relUrl": "/vue#setting-values"
  },"29": {
    "doc": "Vue",
    "title": "Loading",
    "content": "To increase performance, we don’t share every setting with the frontend on every page. Instead, we only load the settings that are actually needed by you. There are two ways to share your settings with your Vue component. You can either do it from your component directly, or eager load them by specifying which settings to load in your Laravel app. Loading through JS . Before you can make use of a setting, call this.$settings.loadSetting('theme') and pass it the setting key or alias to load. This will be loaded in the background. During loading this.$setting.theme will be undefined, but once the setting is ready it will reactively update to the value. You can load many settings at the same time with this.$settings.loadSettings(['theme', 'site_name']). Eager Loading . To avoid the overhead of loading settings from your javascript, you should try and mark settings to share in your laravel app. Any settings loaded this way will be instantly available without having to load them with loadSettings() . For settings that should be loaded on every request, such as a site name, you can put them into the config . [ ..., 'js' =&gt; [ 'autoload' =&gt; [ 'site_name' ] ] ] . For settings that should only be loaded on some requests, add this to your controller or middleware. \\Settings\\Share\\LoadedSettings::eagerLoad('site_name'); . ",
    "url": "/vue#loading",
    "relUrl": "/vue#loading"
  }
}
